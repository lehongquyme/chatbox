<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chatbot Qlife</title>
  <style>
    body { font-family: sans-serif; background: #f5f5f5; padding: 2rem; }
    #chat { max-width: 600px; margin: auto; background: white; padding: 1rem; border-radius: 8px; }
    .message { margin-bottom: 1rem; }
    .user { color: blue; }
    .bot { color: green; }
  </style>
</head>
<body>
  <div class="chat-container">
    <h2>üí¨ Chatbot Qlife</h2>
    
    <div class="chat-history" id="chatHistory">
      <!-- Chat history will be added here by JavaScript -->
    </div>


    <div class="input-section">
      <input type="text" id="messageInput" placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n...">
      <button id="voiceInputBtn" title="G·ª≠i tin nh·∫Øn b·∫±ng gi·ªçng n√≥i">üé§</button> <!-- N√∫t microphone -->
      <button id="sendBtn">G·ª≠i</button>
    </div>
  </div>

  <script>
    const messageInput = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");
    const chatHistoryDiv = document.getElementById("chatHistory");
    const voiceInputBtn = document.getElementById("voiceInputBtn"); // L·∫•y n√∫t micro

    // =================================================================================
    // API BASE URL (VERY IMPORTANT!)
    // Use "http://localhost:8000" for local development.
    // WHEN USING NGROK TO SHARE EXTERNALLY, YOU MUST UPDATE THIS VARIABLE
    // WITH THE LATEST NGROK HTTPS ADDRESS YOU RECEIVE.
    // Example: const apiBaseUrl = "https://abcd-1234-xyz.ngrok-free.app";
    // ENSURE THIS ADDRESS EXACTLY MATCHES YOUR CURRENT NGROK LINK!
    const apiBaseUrl = "https://6e352132955b.ngrok-free.app"; // <--- C·∫¨P NH·∫¨T ƒê·ªäA CH·ªà N√ÄY!
    // =================================================================================

    // Function to create and add a message to the history
    function addMessageToHistory(sender, text, timestamp, isError = false) {
      const messageRow = document.createElement("div");
      messageRow.classList.add("message-row", sender);
      if (isError) {
        messageRow.classList.add("error");
      }

      const timestampSpan = document.createElement("span");
      timestampSpan.classList.add("timestamp");
      timestampSpan.textContent = timestamp;
      
      const messageContent = document.createElement("span");
      messageContent.classList.add("message-content");
      messageContent.textContent = text;

      // Order of adding timestamp and content for correct alignment
      messageRow.appendChild(timestampSpan);
      messageRow.appendChild(messageContent);
      
      chatHistoryDiv.appendChild(messageRow);
      // Scroll to the bottom of the history to show the latest message
      chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    // Function to load chat history when the page loads
    async function loadChatHistory() {
      try {
        console.log(`ƒêang t·∫£i l·ªãch s·ª≠ t·ª´: ${apiBaseUrl}/history`);
        const res = await fetch(`${apiBaseUrl}/history`);
        
        if (!res.ok) {
          const errorText = await res.text(); // Read the response as text for debugging
          console.error("Ph·∫£n h·ªìi kh√¥ng OK:", res.status, res.statusText, errorText);
          throw new Error(`L·ªói HTTP khi t·∫£i l·ªãch s·ª≠: ${res.status} ${res.statusText}. Chi ti·∫øt: ${errorText.substring(0, 100)}...`);
        }
        
        const history = await res.json(); // This is where the "Unexpected token '<'" error might occur
        chatHistoryDiv.innerHTML = ''; // Clear old content before reloading
        history.forEach(msg => {
          addMessageToHistory(msg.sender, msg.text, msg.timestamp, msg.error || false);
        });
      } catch (error) {
        console.error("L·ªói khi t·∫£i l·ªãch s·ª≠ tr√≤ chuy·ªán:", error);
        addMessageToHistory("bot", `Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠ tr√≤ chuy·ªán: ${error.message}`, new Date().toLocaleString(), true);
      }
    }

    // Send message function (now called by both sendBtn and voice input)
    async function sendMessage() {
      const userMessage = messageInput.value.trim();
      if (!userMessage) {
        // Thay th·∫ø alert b·∫±ng m·ªôt th√¥ng b√°o tr√™n UI ho·∫∑c console.error
        console.error("Vui l√≤ng nh·∫≠p tin nh·∫Øn!");
        return;
      }

      sendBtn.disabled = true; // Disable send button to prevent duplicate submissions
      voiceInputBtn.disabled = true; // Disable voice input button
      messageInput.value = ""; // Clear input field
      messageInput.focus(); // Keep focus on input

      // Add user message to history immediately (before sending to backend)
      addMessageToHistory("user", userMessage, new Date().toLocaleString());

      try {
        console.log(`ƒêang g·ª≠i tin nh·∫Øn ƒë·∫øn: ${apiBaseUrl}/chat`);
        const res = await fetch(`${apiBaseUrl}/chat`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ message: userMessage })
        });

        if (!res.ok) {
          const errorDetail = await res.text();
          console.error("Ph·∫£n h·ªìi kh√¥ng OK:", res.status, res.statusText, errorDetail);
          throw new Error(`L·ªói HTTP: ${res.status} ${res.statusText}. Chi ti·∫øt: ${errorDetail.substring(0, 200)}...`);
        }

        const data = await res.json(); // Ensure JSON is received
        
        // Add bot's response to history
        addMessageToHistory("bot", data.text, new Date().toLocaleString(), data.error);

      } catch (error) {
        console.error("L·ªói khi g·ª≠i tin nh·∫Øn ho·∫∑c nh·∫≠n ph·∫£n h·ªìi:", error);
        addMessageToHistory("bot", `L·ªñI K·∫æT N·ªêI/H·ªÜ TH·ªêNG: ${error.message}`, new Date().toLocaleString(), true);
      } finally {
        sendBtn.disabled = false; // Re-enable send button
        voiceInputBtn.disabled = false; // Re-enable voice input button
        // T·∫£i l·∫°i l·ªãch s·ª≠ sau khi bot ƒë√£ tr·∫£ l·ªùi xong ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
        loadChatHistory(); 
      }
    };

    // Event listener for send button
    sendBtn.onclick = sendMessage;

    // Allow sending with Enter key
    messageInput.addEventListener("keypress", function(event) {
      if (event.key === "Enter") {
        event.preventDefault(); // Prevent default Enter behavior (e.g., newline in textarea)
        sendMessage(); // Call the unified sendMessage function
      }
    });

    // =================================================================================
    // VOICE INPUT FEATURE
    // =================================================================================
    let recognition;
    let isRecording = false;

    // Check for browser compatibility
    if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();

      recognition.continuous = false; // Stop after a single utterance
      recognition.interimResults = false; // Only return final results
      recognition.lang = 'vi-VN'; // Set language to Vietnamese

      recognition.onstart = () => {
        isRecording = true;
        voiceInputBtn.classList.add('recording');
        voiceInputBtn.textContent = 'üî¥'; // Change icon to red dot
        console.log('B·∫Øt ƒë·∫ßu ghi √¢m...');
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        messageInput.value = transcript; // Put recognized text into input field
        console.log('B·∫°n ƒë√£ n√≥i:', transcript);
        // Optionally, automatically send the message after recognition
        // sendMessage(); 
      };

      recognition.onend = () => {
        isRecording = false;
        voiceInputBtn.classList.remove('recording');
        voiceInputBtn.textContent = 'üé§'; // Change icon back to microphone
        console.log('K·∫øt th√∫c ghi √¢m.');
        // Sau khi ghi √¢m k·∫øt th√∫c v√† vƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c ƒë∆∞a v√†o input, t·ª± ƒë·ªông g·ª≠i tin nh·∫Øn
        sendMessage(); 
      };

      recognition.onerror = (event) => {
        isRecording = false;
        voiceInputBtn.classList.remove('recording');
        voiceInputBtn.textContent = 'üé§';
        console.error('L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i:', event.error);
        addMessageToHistory("bot", `L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i: ${event.error}. Vui l√≤ng th·ª≠ l·∫°i.`, new Date().toLocaleString(), true);
      };

      voiceInputBtn.onclick = () => {
        if (isRecording) {
          recognition.stop(); // Stop recording if already active
        } else {
          messageInput.value = ''; // Clear input before recording
          recognition.start(); // Start recording
        }
      };
    } else {
      console.warn('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Web Speech API.');
      voiceInputBtn.disabled = true;
      voiceInputBtn.textContent = 'üö´'; // Show disabled icon
      voiceInputBtn.title = 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n d·∫°ng gi·ªçng n√≥i';
    }
    // =================================================================================

    // Load history when the page is fully loaded (initial load)
    window.onload = loadChatHistory;

    // Removed setInterval to avoid frequent history reloads.
    // History will be reloaded on page load and after each bot response.
  </script>
</body>
</html>
